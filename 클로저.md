# 24장 클로저

- 클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다. ex) `하스켈`, `리스프`, `얼랭`, `스칼라` 등

- 클로저는 자바스크립트 고유의 개념이 아니므로 ECMAScript 명세에 클로저의 정의가 등장하지 않는다. 클로저에 대해 MDN은 아래와 같이 정의하고 있다.
>“A closure is the combination of a function and the lexical environment within which that function was declared.”
 클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.

```
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  innerFunc();
}

outerFunc(); // 10
```

- 함수 `outerFunc` 내에서 내부함수 `innerFunc`가 선언되고 호출되었다. 이때 내부함수 `innerFunc`는 자신을 포함하고 있는 외부함수 `outerFunc`의 변수 `x`에 접근할 수 있다. 이는 함수 `innerFunc`가 함수 `outerFunc`의 내부에 선언되었기 때문이다.

- 이 같은 현상이 발생하는 이유는 자바스크립트가 렉시컬 스코프를 따르는 프로그래밍 언어이기 때문이다.

<br>

## 24.1 렉시컬 스코프

- **자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프(정적 스코프)라 한다.**

![image](https://user-images.githubusercontent.com/109563072/187807873-64d95044-a34d-4f80-b017-c776ff986bcb.png)

- 위 코드에서 `foo` 함수와 `bar` 함수는 모두 전역에서 정의된 전역 함수다. 함수의 상위 스코프를 함수를 어디서 정의했는냐에 따라 결정되므로 `foo` 함수와 `bar` 함수의 상위 스코프는 전역이다. 함수의 상위 스코프는 함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.

- **함수의 상위 스코프를 결정한다**는 것은 **렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다**는 것과 같다. 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값이 바로 상위 렉시컬 환경에 대한 참조이며, 이것이 상위 스코프이기 때문이다. 즉, **렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다. 이것이 바로 렉시컬 스코프다.**

<br>

## 24.2 함수 객체의 내부 슬롯[[Environment]]

- 함수가 정의된 환경과 호출되는 환경은 다를 수 있다. 따라서 렉시컬 스코프가 가능하려면 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경 즉, 상위 스코프를 기억해야 한다. 이를 위해 **함수는 자신의 내부 슬롯`[[Environment]]`에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.**

- 함수 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 환경에 의해 결정된 상위 스코프의 참조를 객체 자신의 내부 슬롯`[[Environment]]`에 저장한다. 이때 자신의 내부 슬롯`[[Environment]]`에 저장된 상위 스코프의 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다.

- 왜냐하면 함수 정의가 평가되어 함수 객체를 생성하는 시점은 함수가 정의된 환경, 즉 상위 함수가 평가 또는 실행되고 있는 시점이며, 이때 현재 실행 중인 실행 컨텍스트는 상위 함수의 실행 컨텍스트이기 때문이다.

- 예를 들어 전역에서 정의된 함수 선언문은 전역 코드가 평가되는 시점에 평가되어 함수 객체를 생성한다. 이때 생성된 함수 객체의 내부 슬롯`[[Environment]]`에는 함수 정의가 평가되는 시점, 즉 전역 코드 평가 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 전역 렉시컬 환경의 참조가 저장된다.

- 함수 내부에서 정의된 함수 표현식은 외부 함수코드가 실행되는 시점에 평가되어 함수 객체를 생성한다. 이때 생성된 함수 객체의 내부 슬롯`[[Environment]]`에는 함수 정의가 평가되는 시점, 즉 외부 함수 코드 실행 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경인 외부 함수 렉시컬 환경의 참조가 저장된다.

- **따라서 함수 객체의 내부 슬롯`[[Environment]]`에 저장된 현재 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 바로 상위 스코프다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장될 참조값이다. 함수 객체는 내부 슬롯`[[Environment]]`에 저장한 렉시컬 환경의 참조, 즉 상위 스코프를 자신이 존재하는 한 기억한다.**

![image](https://user-images.githubusercontent.com/109563072/187809035-b1308e43-0b77-412b-bc2c-8fd3351c562c.png)

- 함수 렉시컬 구성 요소인 **외부 렉시컬 환경에 대한 참조에는 함수 객체의 내부 슬롯`[[Environment]]`에 저장된 렉시컬 환경의 참조가 할당된다.**

<br>

## 24.3 클로저와 렉시컬 환경

![image](https://user-images.githubusercontent.com/109563072/187809266-08b4c9a8-c689-45e1-beed-6643125f072c.png)

- **외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.**

- 자바스크립트의 모든 함수는 자신의 상위 스코프를 기억하기 때문에 함수를 어디서 호출하든 상관없이 언제나 자신이 기억하는 상위 스코프의 식별자를 참조할 수 있으며 식별자에 바인딩된 값을 변경할 수도 있다.

- 위 코드에서 `inner` 함수는 자신이 평가될 때 자신이 정의된 위치에 의해 결정된 상위 스코프를 내부 슬롯`[[Environment]]`에 저장한다. 이때 저장된 상위 스코프는 함수가 존재하는 한 유지된다. 

- 위 코드에서 `outer` 함수가 평가되어 함수 객체를 생성할 때 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 전역 렉시컬 환경을 `outer` 함수 객체의 내부 슬롯`[[Environment]]`에 상위 스코프로서 저장한다.

![image](https://user-images.githubusercontent.com/109563072/187810018-5a1ab654-d126-4dfb-ab5d-f6c200a00f57.png)

- `outer` 함수를 호출하면 `outer` 함수의 렉시컬 환경이 생성되고 앞서 `outer` 함수 객체의 내부 슬롯`[[Environment]]`에 저장된 전역 렉시컬 환경을 `outer` 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당한다.

- 그리고 중첩 함수 `inner`가 평가된다. (함수 표현식으로 정의했기 때문에 런타임에 평가) 이때 중첩 함수 `inner`는 자신의 내부 슬롯`[[Environment]]`에 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 `outer` 함수의 렉시컬 환경을 상위 스코프로서 정의한다.

![image](https://user-images.githubusercontent.com/109563072/187810248-6efcc80a-495b-493f-866b-623f4ea852c8.png)

- `outer` 함수의 실행이 종료하면 `inner` 함수를 반환하면서 `outer` 함수의 생명 주기가 종료된다. 즉, `outer` 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거된다. **이때 `outer` 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 `outer` 함수의 렉시컬 환경까지 소멸되는 것은 아니다.**

- `outer` 함수의 렉시컬 환경은 `inner` 함수의 내부 슬롯`[[Environment]]`에 의해 참조되고 있고 `inner` 함수는 전역 변수 `innerFunc`에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 때문이다. 가비지 컬렉터는 누군가가 참조하고 있는 메모리 공간을 함부로 해재하지 않는다.

![image](https://user-images.githubusercontent.com/109563072/187810468-55417c73-af4a-45d5-a911-a6efc95c4b09.png)

- `outer` 함수가 반환한 `inner` 함수를 호출하면 `inner` 함수의 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 푸쉬된다. 그리고 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는 inner 함수 객체의 내부 슬롯`[[Environment]]`에 저장되어 있는 참조값이 할당된다.

![image](https://user-images.githubusercontent.com/109563072/187810578-df43bf84-5b2e-4577-9ffe-de7e52a556c1.png)

- 중첩 함수 `inner`는 외부 함수 `outer`보다 더 오래 생존했다. 이때 외부 함수보다 더 오래 생존한 중첩함수는 외부 함수의 생존 여부와 상관없이 자신이 정의된 위치에 의해 결정된 상위 스코프를 기억한다. 이처럼 중첩 함수 `inner`의 내부에서는 상위 스코프를 참조할 수 있으므로 상위 스코프의 식별자를 참조할 수 있고 값도 변경할 수 있다.

```
function foo() {
  const x = 1;
  const y = 2;

  function bar() {
    const z = 3;

    console.log(z);
  }

  return bar;
}

const bar = foo();
bar();
```

- 위 코드의 중첩 함수 `bar`는 외부 함수 `foo`보다 더 오래 유지되지만 상위 스코프의 어떤 식별자도 참조하지 않기 때문에 `bar` 함수는 클로저라고 할 수 없다.

```
function foo() {
  const x = 1;

  function bar() {
    console.log(x);
  }

  bar();
}

foo();
```

- 위 예제의 중첩 함수 `bar`는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 하지만 외부 함수 `foo`의 외부로 중첩 함수 `bar`가 반환되지 않느다. 즉, 외부 함수 `foo`보다 중첩 함수 `bar`의 생명 주기가 짧다. 이런 경우 `bar` 함수는 클로저라고 할 수 없다.

```
function foo() {
  const x = 1;
  const y = 2;

  function bar() {
    console.log(x);
  }

  return bar;
}

const bar = foo();
bar();
```

- 위 예제의 중첩 함수 `bar`는 상위 스코프의 식별자를 참조하고 있으므로 클로저다. 그리고 외부 함수의 외부로 반환되어 외부 함수보다 더 오래 살아남는다. 

- **클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지하는 경우에 한정하는 것이 일반적이다.**

- 다만 중첩 함수 `bar`는 상위 스코프의 `x`, `y` 식별자 중에서 `x`만 참조하고 있다. 이런 경우 대부분의 모던 브라우저는 상위 스코프의 식별자 중 클로저가 참조하고 있는 식별자만을 기억한다. 

- 클로저에 의해 참조되는 상위 스코프의 변수(foo 함수의 x변수)를 **자유 변수**라고 부른다. 클로저란 함수가 자유 변수에 대해 닫혀있다는 의미로 자유 변수에 묶여있는 함수라고 할 수 있다. 

